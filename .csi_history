(cadr (list (list 1 2) 3))
(cadar (list (list 1 2) 3))
(caar (list (list 1 2) 3))
(car '(cond ((test? true-atom) (proc: effect)) (else (recursion proc))))
(caar '(cond ((test? true-atom) (proc: effect)) (else (recursion proc))))
(cadar '(cond ((test? true-atom) (proc: effect)) (else (recursion proc))))
(car '(cond ((test? true-atom) (proc: effect)) (else (recursion proc))))
(car '(define foo (lambda (x) (cond ((test? true-atom) (proc: effect)) (else (recursion proc))))))
(cdr '(define foo (lambda (x) (cond ((test? true-atom) (proc: effect)) (else (recursion proc))))))
(cadr '(define foo (lambda (x) (cond ((test? true-atom) (proc: effect)) (else (recursion proc))))))
(caar '(define foo (lambda (x) (cond ((test? true-atom) (proc: effect)) (else (recursion proc))))))
(cadar '(define foo (lambda (x) (cond ((test? true-atom) (proc: effect)) (else (recursion proc))))))
(cdadr '(define foo (lambda (x) (cond ((test? true-atom) (proc: effect)) (else (recursion proc))))))
(cadr '(when (> x 10) (print x)))
(cadar '(when (> x 10) (print x)))
(caar '(when (> x 10) (print x)))
(cadr '(when (> x 10) (print x)))
(csdr '(when (> x 10) (print x)))
(cddr '(when (> x 10) (print x)))
(cddr '(define foo (lambda (x) (cond ((test? true-atom) (proc: effect)) (else (recursion proc))))))
(cadr '(define foo (lambda (x) (cond ((test? true-atom) (proc: effect)) (else (recursion proc))))))
(cddr '(define foo (lambda (x) (cond ((test? true-atom) (proc: effect)) (else (recursion proc))))))
(print (cddr '(define foo (lambda (x) (cond ((test? true-atom) (proc: effect)) (else (recursion proc)))))))
(print ":" (cddr '(define foo (lambda (x) (cond ((test? true-atom) (proc: effect)) (else (recursion proc)))))))
(vi)
(cons 1 2)
(car (cons 1 2))
(vi)
(car (cons 1 2))
(cons 1 2)
(vi)
(cons 1 2)
(car(cons 1 2))
(car (cons 1 2))
(define p (cons 1 2))
(p 0)
(p 1)
(p 3)
(vi)
(zip '(1 2 3) '(a b c))
(zip cons '(1 2 3) '(a b c))
(vi)
map
(map (lambda (x) (* 2 x)) (quote (1 2 3 4)))
(begin (map (lambda (x) (* 2 x)) (quote (1 2 3 4))))
(vi)
( define empty_stack ( lambda ( stack ) ( if ( null? stack ) \#t \#f )))
(empty_stack '())
(empty_stack '(f f))
( define empty_stack ( lambda ( stack ) ( if ( null? stack ) #t #f )))
(empty_stack '(f f))
(empty_stack '())
(vi)
(empty-stack? '())
(empty-stack? '(d))
(vi)
(empty-stack? '(d))
(vi)
(empty-stack? '(d))
(empty-stack? '())
(vi)
(empty-stack? '())
(empty-stack? '(f))
(vi)
(empty-stack? '(f))
(empty-stack? '())
(vi)
(empty-stack? '())
(empty-stack? '(s))
(vi)
(push 4 '(2 3 4 5))
(pop (push 4 '(2 3 4 5)))
(top (push 4 '(2 3 4 5)))
(vi)
(pop (push 4 '(2 3 4 5)))
(top (push 4 '(2 3 4 5)))
(vi)
(reverse '(1 2 3 4 5))
(vi)
(reverse '(1 2 3 4 5))
(vi)
(reverse '(1 2 3 4 5))
(vi)
(reverse '(1 2 3 4 5))
(vi)
(+ 2 3 )
(vi)
(define rand (lambda (seed) (% 37 (* 22 seed))))
(rand 44)
(rand 423)
(rand 3)
(rand 2)
(vi)
(fy 5)
(vi)
(fy 5)
(vi)
(fy 5)
(vi)
(last '(one two three four))
(vi)
(last)
(last '(one two three four))
(last '(one two three))
(flatten '())
(flatten '(1 (2 (((3) (()) 4)) 5 (6)) (((7 ((()))))) ))
(vi)
(atom? 'fopo)
(atom? '(fo))
(vi)
(flatten '(1 (2 (((3) (()) 4)) 5 (6)) (((7 ((()))))) ))
(vi)
(flatten '(1 (2 (((3) (()) 4)) 5 (6)) (((7 ((()))))) ))
(vi)
(flatten '(1 (2 (((3) (()) 4)) 5 (6)) (((7 ((()))))) ))
(vi)
(flat '() '(1 (2 (((3) (()) 4)) 5 (6)) (((7 ((()))))) ))
(flat  '(1 (2 (((3) (()) 4)) 5 (6)) (((7 ((()))))) ))
(vi)
(foo)
(car foo)
(vi)
(foo)
(vi)
(foo)
(car foo)
(vi)
(car foo)
(cdr foo)
(vi)
(cdr foo)
(car foo)
(vi)
(append 1)
(append 1 2)
(append (append 1) 2)
(append (append 1) '2)
(car '(1 2 3))
(car '(1 (2 3)))
(csr '(1 (2 3)))
(cdr '(1 (2 3)))
(car '(1 (2 3)))
(cdr (car '(1 (2 3))))
(car (car '(1 (2 3))))
(car (cdr '(1 (2 3))))
(car (car (cdr '(1 (2 3)))))
(cons '1 '())
(cons 1 '())
(cons 1 '(2 3))
(cons '(1 42) '(2 3))
(cons (1 42) '(2 3))
(cons '(1 42) (2 3))
(cons 1 '())
(cons 1 '(2 3))
(cons '(1 42) '(2 3))
(cons '1 '2)
(cons 1 2)
(car (cons 1 2))
(cdr (cons 1 2))
(cdr (cons 1 (2 3)))
(cdr (cons 1 '(2 3)))
(cdr (cons 1 '(2 3Z)))
(not #t)
(and #t #t)
(not (and #t #t))
(or (not #t) (not #t))
(clear)
(not (and #t #t))
(or (not #t) (not #t))
(and (not #t) (not #t))
(not (or #t #t))
(define A (lambda () #t))
A
(A)
(define B (lambda () #t))
(not (and A B))
(or (not A) (not B))
(and (not A) (not B))
(not (or A B))
(define a (lambda () #f))
(define b (lambda () #f))
(not (and A B))
(not (or A B))
(not (and a b))
(or (and a b))
(or (not a b))
(and (not a) (not b))
(vi)
(but-last '(a b c d))
(vi)
(but-last '(a b c d))
(vi)
(but-last '(a b c d))
(vi)
(but-last '(a b c d))
(vi)
(but-last '())
(vi)
(but-last '())
(but-last '(a b c d))
butlast 
(butlast '(a b c d))
(read "3")
(read)
3
(vector->list "foo")
(string->list "foo")
(string->version "foo")
(vector "foo")
(vector |foo|)
(vector '|foo|)
(list '|foo|)
(list 'foo)
(cons 'foo '())
(* 7 &)
(* 7 7)
(* 7(* 7 7))
(* 7 (* 7 (* 7 7)))
(* 1 (* 7 (* 7 (* 7 7))))
(vi)
data
(vi)
(first data)
(vi)
(second data)
(bottomright data)
(bottomleft data)
(topleft data)
(topright data)
(vi)
(define abs (lambda (x) (cond ((< x 0) (- x)) (else x))))
(abs 32)
(abs 3323)
(abs 33.23)
(abs -3323)
(abs -33)
(abs (abs -33))
(* -1 (abs (abs -33)))
(abs (* -1 (abs (abs -33))))
(vi)
(set! Q '(lambda (x y) x))
(set! s11 '(lambda (f x) (list 'lambda '(y) (list f x 'y))))
(set! n (list 'lambda '(x y) (list Q (list s11 'x 'x) 'y)))
(set! p (eval (list s11 n n)))
(eval (cons p '()))
(eval (list p '()))
(eval (list p nil))
(eval (list p 'nil))
(eval (list p ))
(eval (list Q p nil))
(eval (list Q p ))
(eval (list Q p '()))
(pair? '(1 2))
(pair? '(1 2 2))
(pair? '(1 2 ()))
(pair? '(1 2 () ) '(2 3))
(pair? '(1 2 () ) '(2 3)))
(pair? '(1 2 () ) '(2 3))
(vi)
(pair '(1 23) '(2 3))
(pair '(1 23) '(2 3) '(3 4 4)))
(pair '(1 23) '(2 3) '(3 4 4))
(pair '(1 23) '(2 33 33)))
(pair '(1 23) '(2 33))
(pair '(1 23) '(2 33 3))
(pair '(1 23) '(2 33 3 44))
(pair '(1 23 33 ) '(2 33 3 44))
(pair '(1 23 33 3 4 56) '(2 33 3 44))
define (( (not (lambda ((J) (COND (J NIL) (T T)))) ) ))
define
(vi)
(apply '+ lol)
(map '+ lol)
(reduce '+ lol)
(vi)
(* 150 8)
(* 150 10)
(* 12 (* 150 10))
(* 12 (* 150 8))
( - 1899.99 1379.00)
(setq foo "bar")
(vi)
(assert=? 3 (+ 1 2))
(assert=? 3 (+ 2 2))
(vi)
(assert=? 3 (+ 1 2))
(assert=? 3 (+ 2 2))
(vi)
(assert=? 3 (+ 2 2))
(assert=? 3 (+ 1 2))
(assert=? 3 (+ 2 2))
(vi)
(assert=? 3 (+ 2 2))
(assert=? 3 (+ 1 2))
(vi)
(assert=? 3 (+ 1 2))
(vi)
(assert=? 3 (+ 1 2))
(assert=? 3 (+ 2 2))
(vi)
